class SignalK {

    /**
     * Create a new SignalK object and associate it with a Signal K server.
     *
     * <host> is the hostname or IP address of the Signal K server.
     *
     * <port> is the port number on which the Signal K server listens.
     *
     * <getFilter> is a function which can be used to return functions which
     * perform useful conversions on Signal K data values.
     *
     * <createWidget> is a function which creates widgets for displaying
     * Signal K data in real time.
     */

    constructor(hosts=[[ location.hostname, location.port ]], getFilter, createWidget) {
        //console.log("SignalK(%s,%s,%s)...", JSON.stringify(hosts), getFilter, createWidget);
        this.directory = {};
        this.hosts = hosts;
        this.getFilter = getFilter;
        this.createWidget = createWidget;
    }

    /**
     * getValue asynchronously requests a Signal K path value.  The returned
     * result is parsed to JSON, optionally filtered by an external function
     * and returned to the client application via a callback.
     *
     * @param path - Signal K path to be interrogated.
     * @param callback - client callback function.
     * @param filter - optional filter function used to pre-process the value passed to callback.
     */

    getValue(path, async, callback, filter=this.getFilter("identity")) {
        this.httpGet(this.normalisePath(path), async, (v) => {
            v = JSON.parse(v);
            if (typeof v === "object") v = v.value;
            callback(filter(v));
        });
    }

    getObject(path, async, callback, filter=this.getFilter("identity")) {
        this.httpGet(this.normalisePath(path), async, (v) => {
            v = JSON.parse(v);
            callback(filter(v));
        });
    }

    getValues(path, async, callback) {
        this.httpGet(this.normalisePath(path), async, (v) => {
            v = JSON.parse(v);
            if (typeof v === "object") v = v.values;
            callback(v);
        });
    }

    /**
     * interpolateValue is a convenience function which recover a Signal K
     * value using getValue and interpolates the result directly into a
     * specified DOM element.
     *
     * @param path - Signal K path to be interrogated.
     * @param element - DOM element whose content will be overwritten.
     * @param filter - optional filter function used to pre-process the recover path value before interpolation.
     */

    interpolateValue(path, element, async, filter=this.getFilter("identity")) {
        //console.log("interpolateValue(%s,%s,%s)...", path, JSON.stringify(element), JSON.stringify(filter));
        this.getValue(path, async, function(v) { element.innerHTML = v; }, filter);
    }

    /**
     * registerCallback subscribes a callback function so that it will be
     * invoked each time a specified Signal K path value is updated. The delta
     * values returned by the Signal K server are converted to JSON and
     * optionally filters by an external function before being passed to the
     * callback.
     *
     * @param path - Signal K path to be interrogated.
     * @param callback - client callback function.
     * @param filter - optional filter function used to pre-process delta values before they are passed to callback.
     */
    
    registerCallback(path, callback, filter) {
        //console.log("registerCallback(%s,%s,%s)...", path, callback, filter);

        if (this.directory[path] === undefined) this.directory[path] = [];

        var _filter = filter;
        var _callback = callback;

        this.directory[path].push(v => {
            try { v = JSON.parse(v); } catch { }
            if (_filter !== undefined) v = _filter(v);
            switch (typeof _callback) {
                case "object": _callback.update(v); break;
                case "function": _callback(v); break;
                default: break;
            }
        });
    }

    /**
     * registerInterpolation is a convenience function which subscribes for
     * updates on a Signal K path and interpolates delta values directly into
     * a specified DOM element.
     *
     * @param path - Signal K path to be interrogated.
     * @param element - DOM element whose content will be overwritten.
     * @param filter - optional filter function used to pre-process delta values before interpolation.
     */

    registerInterpolation(path, element, filter=this.getFilter("identity")) {
        this.registerCallback(path, function(v) { element.innerHTML = v; }, filter);
    }

	subscribe() {
    	if ("WebSocket" in window) {
		    console.log("SignalK: opening websocket connection to " + this.hosts[0][0] + " on port " + this.hosts[0][1]);
            var [ host, port ] = this.hosts.shift();
       		var ws = new WebSocket("ws://" + host + ":" + port + "/signalk/v1/stream?subscribe=none");
            var directory = this.directory;

        	ws.onopen = function(evt) {
                var deltaCount = Object.keys(directory).length;
                if (deltaCount) {
			        console.log("SignalK: websocket connection established, subscribing to %d delta(s)", deltaCount);
            	    var subscriptions = Object.keys(directory).map(v => ({ "path": v, "minPeriod": 1000, "policy": "instant" }));
            	    var msg = { "context": "vessels.self", "subscribe": subscriptions };
            	    ws.send(JSON.stringify(msg));
                } else {
                    console.log("SignalK: there are no configured delta paths");
                }
        	};
        
	        ws.onmessage = function(evt) {
            	var data = JSON.parse(evt.data);
            	if ((data.updates !== undefined) && (data.updates.length > 0)) data.updates.forEach(update => {
               		if ((update.values !== undefined) && (update.values.length > 0)) update.values.forEach(updateValue => {
               			var path = updateValue.path;
               			var value = updateValue.value;
               			if ((path !== undefined) && (value !== undefined)) directory[path].forEach(callback => {
                            callback(value);
                        });
                    });
               	});
    		}

            ws.onerror = function(evt) {
                if (this.hosts.length > 0) {
                    this.subscribe();
                }
            }

        }
	}

    httpGet(theUrl, async, callback) {
        var xmlHttp = new XMLHttpRequest();
        if (async) {
            xmlHttp.onreadystatechange = function() {
                console.log("Returning async response");
                if (xmlHttp.readyState == 4 && xmlHttp.status == 200) callback(xmlHttp.responseText);
            }
        }
        xmlHttp.open("GET", theUrl, async);
        xmlHttp.send();
        if (!async) {
                console.log("Returning sync response");
                if (xmlHttp.readyState == 4 && xmlHttp.status == 200) callback(xmlHttp.responseText);
        }
    }

    normalisePath(path) {
        var retval = "/signalk/v1/api/vessels/self/";
        var parts = path.split("[");
        retval += parts[0].replace(/\./g, "/");
        if (parts[1] !== undefined) retval += ("[" + parts[1]);
        return(retval);
    }

}

