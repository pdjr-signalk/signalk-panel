/**
 * SignalK - interface to Signal K server data streams.
 *
 * SiknalK implements WebSocket connection to a SignalK server and provides
 * methods for programmatic and event driven access to the Signal K server's
 * data paths.
 *
 * Applications deploying SignalK are encouraged to extend the class and then
 * use the following simple pattern:
 *
 * super(host, port).waitForConnection().then(_ => {
 *     // do application specific stuff
 * });
 *
 * CONNECTION HANDLING
 *
 * SignalK(host, port[, callback])
 *
 * Returns a new SignalK object, associating it with the Signal K server
 * identified by <host>:<port>. The connection attempted asynchronously and the
 * constructor will inevitably return before the putative connection is in a
 * usable state: users should use the waitForConnection method to manage this
 * eventuality. Optionally, a <callback> function can be registered which will
 * be invoked if the server connection should fail.
 *
 * waitForConnection([millis])
 *
 * Returns a promise which will resolve when a connection is established. The
 * frequency at which the connection is polled defaults to 500 milliseconds,
 * but this can be adjusted by supplying the optional <millis> argument.
 *
 * EVENT DRIVEN DATA ACCESS
 *
 * The event driven methods allow the host application to register an arbitrary
 * number of callback functions which will be invoked each time a value on a
 * defined Signal K path is updated.
 *
 * registerCallback(path, callback[, filter])
 *
 * Registers <callback> for invocation when the data value on <path> changes.
 * For convenience, values generated by the Signal K server are automatically
 * processed before being passed to <callback> (see below). If a <filter>
 * function is supplied then the host application can override most of this
 * automatic processing.
 *
 * The value returned from Signal K is processed in the following way.
 *
 * 1. The value is parsed into a JSON value.
 * 2. If <filter> is defined, then the JSON value is processed by <filter>
 *    and the result passed directly to <callback>.
 * 3. Otherwise, if the JSON value is an object AND it contains a "value"
 *    attribute then the value attribute is passed to <callback>.
 * 4. Otherwise, the JSON value is passed to <callback>.
 *
 * registerInterpolation(path, element[, filter[, callbackFilter]])
 *
 * Registers a built-in callback function (using registerCallback) which will
 * attempt to interpolate updates on the specified Signal K <path> directly
 * into the DOM as the HTML content of <element>. <filter>  can be used to
 * process the value before interpolation and <callbackFilter> can be used
 * to pass a filter to registerCallback if so required.
 *
 * PROGRAMMATIC DATA ACCESS
 *
 * The programmatic methods recover a Signal K data value by making a single
 * synchronous or asynchronous call to the Signal K server.
 *
 * getValue(path[, callback[, filter]])
 *
 * Recovers the current value associated with server <path>.  If <filter> is
 * specified the recovered value is processed by the supplied function. If
 * <callback> is undefined or null, then getValue makes a synchronous call to
 * the server and the recovered value is returned as the function result. If a
 * <callback> is supplied, then an asynchronous call is made to the server and
 * the return value of getValue is undefined.
 * 
 * interpolateValue(path, element[, filter[, getFilter]]);
 *
 * A convenience function which interpolates a <path> value recovered using
 * getFilter into the DOM as the HTML content of <element>. The recovered
 * value can be processed using a <filter> function and processing within
 * getValue can be implemented by specifying <getFilter>.
 *
 */

class SignalK {

    constructor(host, port, callback) {
        //console.log("SignalK(%s,%d,%s)...", host, port, callback);

        this.host = host;
        this.port = parseInt(port);
        this.callback = callback;

        this.ws = null;
        this.directory = {};

        if ((host !== undefined) && (port !== undefined)) {
		    console.log("SignalK: opening websocket connection to %s on port %s", host, port);
       	    this.ws = new WebSocket("ws://" + host + ":" + port + "/signalk/v1/stream?subscribe=none");
            var _this = this;
            this.ws.onopen = function(evt) {
                console.log("SignalK: connection established");
            }
            this.ws.onerror = function(evt) {
                console.log("SignalK: connection failed");
                _this.ws = null;
                if (_this.callback) _this.callback();
            }
            this.ws.onmessage = function(evt) { 
                //console.log("SignalK: websocket message received %s", JSON.stringify(evt.data));
                var data = JSON.parse(evt.data);
                if ((data.updates !== undefined) && (data.updates.length > 0)) {
                    data.updates.forEach(update => {
                        var source = update["$source"];
                        var timestamp = update["timestamp"];
   	                    if ((update.values !== undefined) && (update.values.length > 0)) {
                            update.values.forEach(updateValue => {
   		                        var path = updateValue.path;
   		                        var value = updateValue.value;
   		                        if ((path !== undefined) && (value !== undefined) && (_this.directory[path] !== undefined)) {
                                    _this.directory[path].forEach(callback => callback({ "source": source, "timestamp": timestamp, "value": value }));
                                }
                            });
                        }
                    });
                }
            }
        } else {
            console.log("SignalK: invalid host specification");
        }
    }

    getEndpoints(callback) {
        var everything = this.getValue("", undefined, v=>v);
        callback(this.getPath(everything, "", []));
    }
        
    getPath(tree, value, accumulator) {
        if ((tree) && (typeof tree === "object")) {
            var keys = Object.keys(tree);
            if ((keys.length > 0) && (!keys.includes("value"))) {
                keys.forEach(key => {
                    accumulator = this.getPath(tree[key], (value + ((value.length > 0)?".":"") + key), accumulator);
                });
            } else {
                accumulator.push(value);
            }
        } else {
            accumulator.push(value);
        }
        return(accumulator);
    }

    registerCallback(path, callback, filter) {
        //console.log("registerCallback(%s,%s,%s)...", path, callback, filter);

        if (this.ws != null) {
            if (this.directory[path] === undefined) {
                this.directory[path] = [];
                var subscriptions = [ { "path": path, "minPeriod": 1000, "policy": "instant" } ];
                var msg = { "context": "vessels.self", "subscribe": subscriptions };
                this.ws.send(JSON.stringify(msg));
        	}

            var _filter = filter;
            var _callback = callback;

            if (!this.directory[path].includes(callback)) {
                this.directory[path].push(v => {
                    v = (_filter !== undefined)?_filter(v):((v.value !== undefined)?v.value:v);
                    switch (typeof _callback) {
                        case "object": _callback.update(v); break;
                        case "function": _callback(v); break;
                        default: break;
                    }
                });
            } else {
                console.log("SignalK: refusing to register a duplicate callback");
            }
        } else {
            console.log("SignalK: cannot register callback because websocket is not open");
        }
    }

    registerInterpolation(path, element, filter, callbackFilter) {
        //console.log("registerInterpolation(%s,%s,%s,%s)...", path, element, filter, callbackFilter);
 
        this.registerCallback(path, function(v) { element.innerHTML = (filter !== undefined)?filter(v):v; }, callbackFilter);
    }

    getValue(path, callback, filter) {
        //console.log("getValue(%s,%s,%s)...", path, callback, filter);

        var retval = null
        var _callback = callback;
        var _filter = filter;
        
        SignalK.httpGet(SignalK.normalisePath(path), (callback !== undefined), (v) => {
            v = JSON.parse(v);
            v = (_filter !== undefined)?_filter(v):((v.value !== undefined)?v.value:v);
            if (_callback !== undefined) {
                switch (typeof _callback) {
                    case "object": _callback.update(v); break;
                    case "function": _callback(v); break;
                    default: break;
                }
            } else {
                retval = v;
            }
        });
        return(retval);
    }

    interpolateValue(path, element, filter, getFilter) {
        //console.log("interpolateValue(%s,%s,%s,%s)...", path, element, filter, getFilter);

        var _element = element;
        var _filter = filter;
        var _getFilter = getFilter;
        this.getValue(path, function(v) { _element.innerHTML = (_filter !== undefined)?_filter(v):v; }, _getFilter);
    }

    static httpGet(theUrl, async, callback) {
        var xmlHttp = new XMLHttpRequest();
        if (async) {
            xmlHttp.onreadystatechange = function() {
                if (xmlHttp.readyState == 4 && xmlHttp.status == 200) callback(xmlHttp.responseText);
            }
        }
        xmlHttp.open("GET", theUrl, async);
        xmlHttp.send();
        if (!async) {
            if (xmlHttp.readyState == 4 && xmlHttp.status == 200) callback(xmlHttp.responseText);
        }
    }

    static normalisePath(path) {
        var retval = "/signalk/v1/api/vessels/self/";
        var parts = path.split("[");
        retval += parts[0].replace(/\./g, "/");
        if (parts[1] !== undefined) retval += ("[" + parts[1]);
        return(retval);
    }

    waitForConnection(timeout=500) {
        const poll = resolve => {
            if (this.ws.readyState === WebSocket.OPEN) { resolve(); } else { setTimeout(_ => poll(resolve), timeout); }
        }
        return new Promise(poll);
    }

    static parseURL(url) {
        var retval = null;
        var parts = url.split(':');
        if ((parts.length == 2) && (parts[0] == "signalk")) retval = parts[1];
        return(retval);
    }

}
